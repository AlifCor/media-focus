<!doctype html>

<html lang="en">
<head>
    <meta charset="utf-8">

    <title>Data visualization : news and sources of news</title>
    <meta name="description" content="Data visualization : news and sources of news">
    <meta name="author" content="Delisle, Kulovic, Hosseiny">

    <link rel="stylesheet" type="text/css" href="style.css">
    <link rel="stylesheet" type="text/css" href="cdn/accordion.css">
    <link rel="stylesheet" type="text/css" href="cdn/pretty-checkbox.min.css">

    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.2.0/dist/leaflet.css"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <script src="https://unpkg.com/leaflet@1.2.0/dist/leaflet.js"></script>

</head>

<body>

<!--
 Inspired by those:
 - https://ihatetomatoes.net/create-custom-preloading-screen/
 - https://ihatetomatoes.net/create-css3-spinning-preloader/
 -->
<div id="loader-wrapper">
    <div id="loader"></div>

    <div class="loader-section section-left"></div>
    <div class="loader-section section-right"></div>

</div>
<div id="main_container">
    <div id="side_country_details">
        <svg id="container_sankey_countries">

        </svg>

        <svg id="container_sankey_events">

        </svg>

        <div id="country_close_btn">
            <i id="icon_ccb" class="fa fa-arrow-left"></i>
        </div>

    </div>
    <div id="container_map">

    </div>
    <div id="side_menu">
        <a id="pull"></a>
        <div id="side_events">
            <!-- Inspired by https://codepen.io/agrayson/pen/aLpKB -->
            <div id="accordion" class="acc-container">
            </div>
        </div>
    </div>
</div>

<script
        src="cdn/leaflet-heat.js">
</script>

<script src="cdn/d3/d3.min.js"></script>
<script src="cdn/d3-sankey/d3-sankey.js"></script>
<script src="cdn/jquery-3.2.1.min.js"></script>
<script src="cdn/dist/PruneCluster.js"></script>
<script>

    function getFilteredEvents(callback) {
        d3.csv("november_lat_long_eventcode.csv", (data) => {
            let filteredEvents = data;
            callback(filteredEvents);
        });
    }

    // Constants:
    const SOURCE_COUNTRY_COL = "source_country_name";
    const EVENT_COUNTRY_COL = "country_name";
    const EVENT_CODE_TYPE = "EventRootCode";
    const LAT_COL = "ActionGeo_Lat";
    const LONG_COL = "ActionGeo_Long";


    // Here we declare the general DOM references
    let sideEventsDrawer = $("#side_menu");
    let containerMap = $("#container_map");
    let sideCountryDetails = document.getElementById("side_country_details");
    let countryCloseBtn = document.getElementById("country_close_btn");

    // We also create our Leaflet map
    let map = L.map('container_map', {zoomControl: false}).setView([39.74739, -105], 4);

    let tileLayer = L.tileLayer('https://api.tiles.mapbox.com/v4/{id}/{z}/{x}/{y}.png?access_token={accessToken}', {
        attribution: 'Map data &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors, <a href="http://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, Imagery © <a href="http://mapbox.com">Mapbox</a>',
        maxZoom: 18,
        id: 'mapbox.streets',
        accessToken: 'pk.eyJ1IjoiYWhtZWRrdWxvdmljIiwiYSI6ImNqYTR2Mmp1dTlsbmoycXB5aXkyOXdtMjkifQ.sU3WNVes2qNhTFH-0nAzYA'
    });
    tileLayer.addTo(map);

    // Here are the "global variables" for our document
    let showEventSideMenu = false;


    // Some general functions:

    function upperFirstLetters(str) {
        return str
            .toLowerCase()
            .split(' ')
            .map((w) => {
                if (w.length > 2) {
                    return w[0].toUpperCase() + w.substr(1);
                }
                else {
                    return w;
                }
            })
            .join(' ');
    }

    function prepareAccordion() {
        let animTime = 300,
            clickPolice = false;

        $(document).on('touchstart click', '.acc-btn', function () {
            if (!clickPolice) {
                clickPolice = true;

                let currIndex = $(this).index('.acc-btn'),
                    targetHeight = $('.acc-content-inner').eq(currIndex).outerHeight();

                $('.acc-btn h1').removeClass('selected');
                $(this).find('h1').addClass('selected');

                $('.acc-content').stop().animate({height: 0}, animTime);
                $('.acc-content').eq(currIndex).stop().animate({height: targetHeight}, animTime);

                setTimeout(function () {
                    clickPolice = false;
                }, animTime);
            }

        });
    }

    $(document).ready(() => {
            containerMap.hover(() => {
                    sideEventsDrawer.stop();
                    sideEventsDrawer.animate({
                        right: "-" + sideEventsDrawer.width() + "px"
                    }, 200);
                }
            );

            sideEventsDrawer.hover(() => {
                    sideEventsDrawer.stop();
                    sideEventsDrawer.animate({
                        right: "0px"
                    }, 200);
                }
            );
        }
    );

    let mainCanvas = L.canvas();
    let currentClusteringLevel = -1;

    function drawData(dataToShow, groupingFunction, canvas, color) {
        const grouped = d3.nest()
            .key(d => [groupingFunction(d[LAT_COL]), groupingFunction(d[LONG_COL])])
            .rollup(group => [group.length, d3.nest().key(d => d[SOURCE_COUNTRY_COL]).entries(group), d3.nest().key(d => d[SOURCE_COUNTRY_COL]).key(d => d["QuadClass"]).entries(group)])
            .entries(dataToShow);
        grouped.forEach((data, index) => {
            const latlngArray = data.key.split(",");
            const latlng = new L.LatLng(latlngArray[0], latlngArray[1]);
            let circle = L.circleMarker(latlng, {
                renderer: canvas,
                stroke: false,
                fillColor: color,
                radius: Math.sqrt(data.value[0]) + 1,
            })
            circle.on("click", () => {
                const neededEvents = data.value[1]
                    .sort((a, b) => b.values.length - a.values.length)
                    .slice(0, 6);
                let div = document.createElement("div");
                console.log(data.value[2])
                console.log(neededEvents)
                //let div = $("<div style=\"width: 200px; height: 200px;\"><svg width=\"200px\" height=\"200px\"><svg/></div>")[0];
                //let svg = d3.select(div).select("svg");
                let svg = d3.select(div)
                    .attr("width", 200)
                    .attr("height", 200)
                .append("svg")
                    .attr("width", 200)
                    .attr("height", 200);
                /*

                let margin = {top: 20, right: 20, bottom: 30, left: 40},
                let width = +svg.attr("width") - margin.left - margin.right,
                let height = +svg.attr("height") - margin.top - margin.bottom,
                let g = svg.append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");
                let x = d3.scaleBand()
                    .rangeRound([0, width])
                    .paddingInner(0.05)
                    .align(0.1);
                let y = d3.scaleLinear()
                    .rangeRound([height, 0]);
                let z = d3.scaleOrdinal()
                    .range(["#98abc5", "#8a89a6", "#7b6888", "#6b486b", "#a05d56", "#d0743c", "#ff8c00"]);
                */
                console.log(svg.attr("width"))
                let margin = {top: 20, right: 20, bottom: 30, left: 40};
                let width = +svg.attr("width") - margin.left - margin.right,
                    height = +svg.attr("height") - margin.top - margin.bottom;

                console.log(width)

                let x = d3.scaleBand().rangeRound([0, width]).padding(0.1),
                    y = d3.scaleLinear().rangeRound([height, 0]);

                let g = svg.append("g")
                    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

                x.domain(neededEvents.map(function(d) { return d.key; }));
                y.domain([0, d3.max(neededEvents, function(d) { return d.values.length; })]);

                g.append("g")
                    .attr("class", "axis axis--x")
                    .attr("transform", "translate(0," + height + ")")
                    .call(d3.axisBottom(x));

                g.append("g")
                    .attr("class", "axis axis--y")
                    .call(d3.axisLeft(y).ticks(10, "%"))
                .append("text")
                    .attr("transform", "rotate(-90)")
                    .attr("y", 6)
                    .attr("dy", "0.71em")
                    .attr("text-anchor", "end")
                    .text("Number of events");

                g.selectAll(".bar")
                    .data(neededEvents)
                .enter().append("rect")
                    .attr("class", "bar")
                    .attr("x", function(d) { return x(d.key); })
                    .attr("y", function(d) { return y(d.values.length); })
                    .attr("width", x.bandwidth())
                    .attr("height", function(d) { return height - y(d.values.length); });

                circle.bindPopup(div);
                circle.openPopup();
            })
            circle.addTo(map);
        })
    }

    function startLoadingScreen() {
        $("body").removeClass('loaded');
    }

    function endLoadingScreen() {
        $("body").addClass('loaded');
    }


    function switchLoadingScreen() {
        $('body').toggleClass('loaded');
    }

    let firstLoad = true;

    function renderMainCanvas(doBefore = startLoadingScreen, doAfter = endLoadingScreen) {
        if (doBefore !== undefined) {
            doBefore();
        }

        function getClusteringLevel(zoomLevel) {
            if (zoomLevel >= 0 && zoomLevel < 6) {
                return 0;
            } else if (zoomLevel >= 6) {
                return 1;
            }
        }

        const currentZoom = map.getZoom();
        const newClusteringLevel = getClusteringLevel(currentZoom);
        if (newClusteringLevel !== currentClusteringLevel) {
            mainCanvas.removeFrom(map);
            let groupingFunction = (coord) => coord;
            switch (currentClusteringLevel) {
                case 0:
                    groupingFunction = (coord) => (Math.round(coord));
                    break;
                case 1:
                    groupingFunction = (coord) => coord;
                    break;
                default:
                    break;
            }
            getFilteredEvents((filteredEvents) => {
                    drawData(filteredEvents, groupingFunction, mainCanvas, "red");
                    if (doAfter !== undefined) {
                        doAfter();
                        if (firstLoad) {
                            firstLoad = false;

                            setTimeout(() => sideEventsDrawer.animate({
                                right: "-" + sideEventsDrawer.width() / 4 + "px"
                            }, 300), 500);

                            setTimeout(() => sideEventsDrawer.animate({
                                right: "-" + sideEventsDrawer.width() + "px"
                            }, 200), 1300);
                        }
                    }
                }
            );
        }
        currentClusteringLevel = newClusteringLevel;
    }

    renderMainCanvas();

    // Corresponds to the elements we want to show when we hover on the sankey links
    let overCanvas = L.canvas();

    function renderOverCanvas(filterFun) {
        overCanvas.removeFrom(map);
        getFilteredEvents((filteredEvents) => {
            sourceTargetFilteredEvents = filteredEvents.filter(filterFun);
            drawData(sourceTargetFilteredEvents, coord => coord, overCanvas, "blue");
        });
    }

    function showCountryDetails(countryCode) {
        selectedCountry = countryCode;
        sideCountryDetails.style.marginLeft = "0%";
        renderSankey();
    }

    function closeCountryDetails() {
        sideCountryDetails.style.marginLeft = "-40%";
    }

    countryCloseBtn.addEventListener("click", closeCountryDetails);

    let svg = d3.select("#container_map").select("svg"),
        g = svg.append("g");

    let canvas = L.canvas();
    let canvasFilter = L.canvas();
    // let currentClusteringLevel = -1;

    let geoJSONData = "data/custom.geo.json";
    let customStyle = {
        stroke: false,
        //weight: 1.2,
        zIndex: 2,
        cursor: "pointer",
    };

    function clickFeature(e, properties) {
        let layer = e.target;
        showCountryDetails(properties["name"]);
    }

    let boundingCountries = {};

    function onEachFeature(feature, layer) {
        layer.on("click", function (e) {
            clickFeature(e, feature.properties);
        });
        layer.addEventListener("mouseover", function () {
            console.log("mouseover")
            this.setStyle({
                "fillColor": "black",
            });
        });
        layer.on("mouseout", function () {
            console.log("mouseout")
            this.setStyle({
                "fillColor": "none",
            });
        });
        boundingCountries[feature.properties["name"]] = layer.getBounds();
    }

    $.get(geoJSONData, function (data) {

        L.geoJson(data, {
            clickable: true,
            style: customStyle,
            onEachFeature: onEachFeature,
        }).addTo(map);
    });

    let currentSankeyCountriesGraph = {
        nodes: [],
        links: [],
    };

    let currentSankeyEventsGraph = {
        nodes: [],
        links: [],
    };

    function updateSankey() {
        let selectionSankeyContainer = d3.select("#container_sankey_countries");
        selectionSankeyContainer.selectAll("svg > *").remove();
        let bboxSankeyContainer = selectionSankeyContainer.node().getBoundingClientRect();

        let svg = d3.select("svg"),
            width = bboxSankeyContainer.width,
            height = bboxSankeyContainer.height;

        svg.attr("width", width)
            .attr("height", height);

        let formatNumber = d3.format(",.0f"),
            format = function (d) {
                return formatNumber(d) + " TWh";
            },
            color = d3.scaleOrdinal(d3.schemeCategory10);

        let sankey = d3.sankey()
            .nodeWidth(15)
            .nodePadding(10)
            .extent([[1, 1], [width - 1, height - 6]]);

        function handleMouseOverLink(d) {
            d3.select(this).attr(
                "stroke", "blue",
            );
            renderOverCanvas(row => row[SOURCE_COUNTRY_COL] === d.source.name &&
                row[EVENT_COUNTRY_COL] === d.target.name);
        }

        function handleMouseOutLink(d) {
            d3.select(this).attr(
                "stroke", "#000",
            );
            overCanvas.removeFrom(map);
        }

        function handleClickLink(d) {
            let country = d.target.name;
            map.fitBounds(boundingCountries[country]);
        }

        let link = svg.append("g")
            .attr("class", "links")
            .attr("fill", "none")
            .attr("stroke", "#000")
            .attr("stroke-opacity", 0.2)
            .attr("border", "2px solid red")
            .selectAll("path")

        let node = svg.append("g")
            .attr("class", "nodes")
            .attr("font-family", "sans-serif")
            .attr("font-size", 10)
            .selectAll("g");

        sankey(currentSankeyCountriesGraph);

        link = link
            .data(currentSankeyCountriesGraph.links)
            .enter().append("path")
            .attr("d", d3.sankeyLinkHorizontal())
            .attr("stroke-width", function (d) {
                return Math.max(1, d.width);
            })
            .on("mouseover", handleMouseOverLink)
            .on("mouseout", handleMouseOutLink)
            .on("click", handleClickLink);

        link.append("title")
            .text(function (d) {
                return d.source.name + " → " + d.target.name + "\n" + format(d.value);
            });

        node = node
            .data(currentSankeyCountriesGraph.nodes)
            .enter().append("g");

        node.append("rect")
            .attr("x", function (d) {
                return d.x0;
            })
            .attr("y", function (d) {
                return d.y0;
            })
            .attr("height", function (d) {
                return d.y1 - d.y0;
            })
            .attr("width", function (d) {
                return d.x1 - d.x0;
            })

            .attr("stroke", "#000");

        node.append("text")
            .attr("x", function (d) {
                return d.x0 - 6;
            })
            .attr("y", function (d) {
                return (d.y1 + d.y0) / 2;
            })
            .attr("dy", "0.35em")
            .attr("text-anchor", "end")
            .text(function (d) {
                return d.name;
            })
            .filter(function (d) {
                return d.x0 < width / 2;
            })
            .attr("x", function (d) {
                return d.x1 + 6;
            })
            .attr("text-anchor", "start");

        node.append("title")
            .text(function (d) {
                return d.name + "\n" + format(d.value);
            });
    }

    function renderSankey() {
        getFilteredEvents(data => {
            let countriesMentions = {};
            let eventMentions = {};
            let eventMentionsSelCountry = {};

            data.forEach((row) => {
                const sourceCountry = row[SOURCE_COUNTRY_COL];
                const eventCountry = row[EVENT_COUNTRY_COL];

                if (!(sourceCountry in countriesMentions)) {
                    countriesMentions[sourceCountry] = {};
                }
                if (!(eventCountry in countriesMentions[sourceCountry])) {
                    countriesMentions[sourceCountry][eventCountry] = 0;
                }

                countriesMentions[sourceCountry][eventCountry] += 1;

                const eventType = row[EVENT_CODE_TYPE];
                if (!(eventType in eventMentions)) {
                    eventMentions[eventType] = {};
                }

                if (!(eventCountry in eventMentions[eventType])) {
                    eventMentions[eventType][eventCountry] = 0;
                }

                eventMentions[eventType][eventCountry] += 1;

                if (sourceCountry === selectedCountry) {
                    if (!(eventType in eventMentionsSelCountry)) {
                        eventMentionsSelCountry[eventType] = 0;
                    }
                    eventMentionsSelCountry[eventType] += 1
                }
            });

            function normalizeMentions(mentions) {
                return Object.keys(mentions).map(source => {
                    const currentSTArray = Object.keys(mentions[source]);
                    const sumMentions = currentSTArray.reduce((sum, target) => {
                        return sum + mentions[source][target];
                    }, 0);
                    return [source, currentSTArray.map(country => [country, mentions[source][country] / sumMentions])];
                })
            }

            countriesMentions = normalizeMentions(countriesMentions);
            eventMentions = normalizeMentions(eventMentions);

            // C is for countries, E for events
            let selectedMentionsC = {};
            let reverseSelectedMentionsC = {};

            let selectedMentionsE = {};
            let reverseSelectedMentionsE = {};

            countriesMentions.forEach(sourceTarget => {
                const sourceCountry = sourceTarget[0];
                const targets = sourceTarget[1];
                targets.forEach(target => {
                    const targetCountry = target[0];
                    const value = target[1];
                    if (targetCountry === selectedCountry) {
                        reverseSelectedMentionsC[sourceCountry] = value;
                    } else if (sourceCountry === selectedCountry) {
                        selectedMentionsC[targetCountry] = value;
                    }
                });
            });

            eventMentions.forEach(sourceTarget => {
                const sourceEvent = sourceTarget[0];
                const targets = sourceTarget[1];
                targets.forEach(target => {
                    const targetCountry = target[0];
                    const value = target[1];
                    if (targetCountry === selectedCountry) {
                        reverseSelectedMentionsE[sourceEvent] = value;
                    }
                });
            });


            reverseSelectedMentionsC = Object.entries(reverseSelectedMentionsC).sort((a, b) => b[1] - a[1]).splice(0, 8);
            // Normalizing reverseSelectedMentionsC:
            const sumRSM = reverseSelectedMentionsC.reduce((sum, elem) => sum + elem[1], 0);
            reverseSelectedMentionsC = reverseSelectedMentionsC.map(elem => [elem[0], elem[1] / sumRSM]);
            const reverseNodes = reverseSelectedMentionsC.map(elem => {
                return {name: elem[0]};
            });
            const reverseLinks = reverseSelectedMentionsC.map((elem, index) => {
                return {source: index, target: reverseNodes.length, value: elem[1]};
            });

            selectedMentionsC = Object.entries(selectedMentionsC).sort((a, b) => b[1] - a[1]).splice(0, 8);
            // Normalizing reverseSelectedMentionsC:
            const sumSM = selectedMentionsC.reduce((sum, elem) => sum + elem[1], 0);
            selectedMentionsC = selectedMentionsC.map(elem => [elem[0], elem[1] / sumSM]);
            let rightNodes = selectedMentionsC.map(elem => {
                return {name: elem[0]};
            });
            const rightLinks = selectedMentionsC.map((elem, index) => {
                return {source: reverseNodes.length, target: index + reverseNodes.length + 1, value: elem[1]}
            });

            const nodes = reverseNodes.concat([{name: selectedCountry}]).concat(rightNodes);
            const links = reverseLinks.concat(rightLinks);

            currentSankeyCountriesGraph = {
                nodes: nodes,
                links: links
            };

            updateSankey(currentSankeyCountriesGraph);
        })
    }

    const defaultCountry = "United States";
    let selectedCountry = defaultCountry;

    window.onresize = function () {
        updateSankey();
    };

    d3.tsv("CAMEO.eventcodes.txt", function (data) {
        eventCodes = data.filter((cameoElem) => cameoElem.CAMEOEVENTCODE.length === 3);
        selectedEventCodes = eventCodes.map(cameoElem => cameoElem.CAMEOEVENTCODE);
        const containerEventSelection = $("#accordion");

        const topEvents = data.filter((cameoElem) => cameoElem.CAMEOEVENTCODE.length === 2);

        topEvents.forEach((cameoElem, index) => {
            const accBtn = $("<div/>").addClass("acc-btn").appendTo(containerEventSelection);
            $("<h1/>").text(cameoElem.CAMEOEVENTCODE + ". " + upperFirstLetters(cameoElem.EVENTDESCRIPTION)).addClass(index === 0 ? "selected" : null).appendTo(accBtn);

            const accContent = $("<div/>").addClass("acc-content" + (index === 0 ? " open" : "")).appendTo(containerEventSelection);
            $("<div/>").attr("id", "events-" + cameoElem.CAMEOEVENTCODE).addClass("acc-content-inner").appendTo(accContent);
        });

        eventCodes.forEach((cameoElem, index) => {
            const id = "box-" + cameoElem.CAMEOEVENTCODE;
            const container = $(`#events-${cameoElem.CAMEOEVENTCODE.substr(0, 2)}`);

            $("<div/>").addClass("pretty p-default p-smooth p-bigger").append(
                $("<input/>", {
                    "type": "checkbox",
                    "checked": true,
                    "id": id
                }).change(
                    function () {
                        if ($(this).is(":checked") && selectedEventCodes.indexOf(cameoElem.CAMEOEVENTCODE) < 0) {
                            selectedEventCodes.push(cameoElem.CAMEOEVENTCODE);
                        } else if (!$(this).is(":checked")) {
                            const indexElem = selectedEventCodes.indexOf(cameoElem.CAMEOEVENTCODE);
                            if (indexElem >= 0) {
                                selectedEventCodes.splice(indexElem, 1);
                            }
                        }
                    }
                )
            ).append(
                $("<div/>").addClass("state p-success").append(
                    $("<label>" + cameoElem.CAMEOEVENTCODE.substr(2) + ". " + upperFirstLetters(cameoElem.EVENTDESCRIPTION) + "</label>").attr({
                        "for": id,
                        "class": "label_event_checkbox"
                    })
                )
            ).appendTo(container);

            if (index === eventCodes.length - 1) {
                prepareAccordion();
            }
        });
    });

    //preprocessMentions();
</script>
</body>
</html>
